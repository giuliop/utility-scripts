#!/bin/bash
# project_tree.sh
#
# This script recursively lists the directory structure (including hidden files)
# starting from a supplied directory (or the current directory by default) up to a given number of levels
# (default: 3). Optionally, you can supply additional arguments that list directory names to ignore.
# Directories matching these names will be printed in the output but not expanded.
#
# Usage:
#   ./project_tree.sh [directory_path] [levels] [ignore_dir1] [ignore_dir2] ...
#
# Example:
#   ./project_tree.sh /path/to/project 4 .git node_modules

# --- Set defaults ---
# Use first argument as path (or current directory)
BASE_DIR="${1:-.}"

# Use second argument as max levels (or default to 3)
MAX_LEVEL="${2:-3}"

# Verify that MAX_LEVEL is a positive integer
if ! [[ "$MAX_LEVEL" =~ ^[0-9]+$ && "$MAX_LEVEL" -gt 0 ]]; then
  echo "Error: The number of levels must be a positive integer."
  exit 1
fi

# Check that BASE_DIR exists and is a directory
if [ ! -d "$BASE_DIR" ]; then
  echo "Error: Directory '$BASE_DIR' does not exist."
  exit 1
fi

# Capture the full command line used to invoke the script before shifting.
GENERATED_BY="// generated by: $0 $*"

# Process additional arguments as directories to ignore.
shift 2
IGNORE_DIRS=("$@")

# Create the output file "project_structure.txt" in the BASE_DIR.
# We use a temporary file so that the generated file isn’t included in the listing.
OUTPUT_FILE="$BASE_DIR/project_structure.txt"
TMP_OUTPUT=$(mktemp)

# Write the header into the temporary output file.
echo "$GENERATED_BY" > "$TMP_OUTPUT"
echo >> "$TMP_OUTPUT"

# Enable dotglob so that the '*' glob includes hidden files (except . and ..)
shopt -s dotglob

# Recursive function to print the tree structure.
# Arguments:
#   $1 - current directory to list
#   $2 - prefix string for indentation
#   $3 - current level (starting at 0)
print_tree() {
  local current_dir="$1"
  local prefix="$2"
  local level="$3"

  # At the very top level (level 0), print the directory’s basename with a trailing slash.
  if [ "$level" -eq 0 ]; then
    echo "$(basename "$current_dir")/" >> "$TMP_OUTPUT"
  fi

  # Stop if we’ve reached the maximum level.
  if [ "$level" -ge "$MAX_LEVEL" ]; then
    return
  fi

  # Gather immediate children (files and directories)
  local children=()
  for entry in "$current_dir"/*; do
    # If no files match the pattern, skip.
    [ -e "$entry" ] || continue

    # Skip the generated output file in the base directory.
    if [ "$current_dir" = "$BASE_DIR" ] && [ "$(basename "$entry")" = "project_structure.txt" ]; then
      continue
    fi

    children+=("$entry")
  done

  # Nothing to print if no children.
  [ "${#children[@]}" -eq 0 ] && return

  # Optionally sort the children alphabetically.
  sorted_children=()
  while IFS= read -r line; do
      sorted_children+=("$line")
  done < <(printf "%s\n" "${children[@]}" | sort)
  children=("${sorted_children[@]}")
  unset IFS

  local total="${#children[@]}"
  local i=0
  local new_prefix

  for child in "${children[@]}"; do
    ((i++))
    local base_name
    base_name="$(basename "$child")"
    local branch

    if [ "$i" -eq "$total" ]; then
      branch="└── "
      new_prefix="${prefix}    "
    else
      branch="├── "
      new_prefix="${prefix}│   "
    fi

    if [ -d "$child" ]; then
      # Print the directory name.
      echo "${prefix}${branch}${base_name}/" >> "$TMP_OUTPUT"

      # Check if this directory is in the ignore list.
      local is_ignored=false
      for ignore in "${IGNORE_DIRS[@]}"; do
        if [ "$base_name" = "$ignore" ]; then
          is_ignored=true
          break
        fi
      done

      # Only expand (recurse into) the directory if it is not ignored.
      if [ "$is_ignored" = false ]; then
        print_tree "$child" "$new_prefix" $((level + 1))
      fi
    else
      echo "${prefix}${branch}${base_name}" >> "$TMP_OUTPUT"
    fi
  done
}

# Start the recursive listing from BASE_DIR.
print_tree "$BASE_DIR" "" 0

# Move the temporary output to the final file.
mv "$TMP_OUTPUT" "$OUTPUT_FILE"

echo "Project structure written to: $OUTPUT_FILE"
